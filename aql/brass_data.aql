typeside sql1 = literal {
        imports sql
        java_functions
            EqualStr : String, String -> Bool = "attributes input[0].equals(input[1])"
            EqualVc : Varchar, Varchar -> Bool = "attributes input[0].equals(input[1])"
            EqualInt : Integer, Integer -> Bool = "attributes input[0].equals(input[1])"
        }
schema S = literal : sql1 {
  e
  n
  t
  i
  t
  i
  e
  s
   
    cot_position
    cot_event
    source
  f
  o
  r
  e
  i
  g
  n
  _
  k
  e
  y
  s
   
    source_id : cot_event -> source
    has_cot_event : cot_position -> cot_event
  p
  a
  t
  h
  _
  e
  q
  u
  a
  t
  i
  o
  n
  s
   
    clojure.lang.LazySeq@1
  a
  t
  t
  r
  i
  b
  u
  t
  e
  s
   
    tileY : cot_position -> Integer
    point_ce : cot_position -> Integer
    servertime : cot_event -> Bigint
    longitude : cot_position -> Real
    cot_type : cot_event -> Varchar
    detail : cot_event -> Text
    latitude : cot_position -> Real
    name : source -> Varchar
    tileX : cot_position -> Integer
    point_le : cot_position -> Integer
    how : cot_event -> Varchar
    channel : source -> Varchar
    point_hae : cot_position -> Integer
}

schema X = literal : sql1 {
  e
  n
  t
  i
  t
  i
  e
  s
   
    cot_cospan
  f
  o
  r
  e
  i
  g
  n
  _
  k
  e
  y
  s
   
    clojure.lang.LazySeq@1
  p
  a
  t
  h
  _
  e
  q
  u
  a
  t
  i
  o
  n
  s
   
    clojure.lang.LazySeq@1
  a
  t
  t
  r
  i
  b
  u
  t
  e
  s
   
    tileY : cot_cospan -> Integer
    point_ce : cot_cospan -> Integer
    servertime : cot_cospan -> Bigint
    longitude : cot_cospan -> Real
    cot_type : cot_cospan -> Varchar
    detail : cot_cospan -> Text
    latitude : cot_cospan -> Real
    name : cot_cospan -> Varchar
    tileX : cot_cospan -> Integer
    point_le : cot_cospan -> Integer
    how : cot_cospan -> Varchar
    channel : cot_cospan -> Varchar
    point_hae : cot_cospan -> Integer
}

mapping F = literal : S -> X {
  e
  n
  t
  i
  t
  y
   
  s
  o
  u
  r
  c
  e
   
  -
  >
   
  c
  o
  t
  _
  c
  o
  s
  p
  a
  n
    f
    o
    r
    e
    i
    g
    n
    _
    k
    e
    y
    s
     
      clojure.lang.LazySeq@1
    a
    t
    t
    r
    i
    b
    u
    t
    e
    s
     
      name -> name
      channel -> channel
  e
  n
  t
  i
  t
  y
   
  c
  o
  t
  _
  e
  v
  e
  n
  t
   
  -
  >
   
  c
  o
  t
  _
  c
  o
  s
  p
  a
  n
    f
    o
    r
    e
    i
    g
    n
    _
    k
    e
    y
    s
     
      source_id -> cot_cospan
    a
    t
    t
    r
    i
    b
    u
    t
    e
    s
     
      cot_type -> cot_type
      how -> how
      detail -> detail
      servertime -> servertime
  e
  n
  t
  i
  t
  y
   
  c
  o
  t
  _
  p
  o
  s
  i
  t
  i
  o
  n
   
  -
  >
   
  c
  o
  t
  _
  c
  o
  s
  p
  a
  n
    f
    o
    r
    e
    i
    g
    n
    _
    k
    e
    y
    s
     
      has_cot_event -> cot_cospan
    a
    t
    t
    r
    i
    b
    u
    t
    e
    s
     
      point_hae -> point_hae
      point_ce -> point_ce
      point_le -> point_le
      tileX -> tileX
      tileY -> tileY
      latitude -> latitude
      longitude -> longitude
}

schema T = literal : sql1 {
  p
  a
  t
  h
  _
  e
  q
  u
  a
  t
  i
  o
  n
  s
   
    clojure.lang.LazySeq@1
  a
  t
  t
  r
  i
  b
  u
  t
  e
  s
   
    tileY : default -> Integer
    point_ce : default -> Integer
    servertime : default -> Bigint
    longitude : default -> Real
    cot_type : default -> Varchar
    detail : default -> Text
    latitude : default -> Real
    name : source -> Varchar
    tileX : default -> Integer
    point_le : default -> Integer
    how : default -> Varchar
    channel : source -> Varchar
    point_hae : default -> Integer
}

mapping G = literal : X -> T {
  e
  n
  t
  i
  t
  y
   
  s
  o
  u
  r
  c
  e
   
  -
  >
   
  c
  o
  t
  _
  c
  o
  s
  p
  a
  n
    f
    o
    r
    e
    i
    g
    n
    _
    k
    e
    y
    s
     
      clojure.lang.LazySeq@1
    a
    t
    t
    r
    i
    b
    u
    t
    e
    s
     
      name -> name
      channel -> channel
}

query Qx = [ toCoQuery G ; toQuery F ]
query Qs_01 = simple : S  {
    from
     ce:cot_event
    where
     ce.cot_type = "a-n-A-C-F-m"
    foreign_keys
     source_id -> ce.source_id
    attributes
     cot_type -> ce.cot_type
    }
query Qt_01 = [ Qx ; Qs_01 ]
query Qs_02 = simple : S  {
    from
     ce:cot_event
    where
     ce.servertime = "201705071635"
    foreign_keys
     source_id -> ce.source_id
    attributes
     cot_type -> ce.cot_type
     how -> ce.how
    }
query Qt_02 = [ Qx ; Qs_02 ]